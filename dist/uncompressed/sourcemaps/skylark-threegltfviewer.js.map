{"version":3,"sources":["skylark-threegltfviewer.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"../skylark-threegltfviewer.js","sourcesContent":["define('skylark-threegltfviewer/threegltviewer',[\r\n\t\"skylark-langx-ns\"\r\n],function(skylark){\r\n\treturn skylark.attach(\"intg.threegltviewer\",{})\r\n});\ndefine('skylark-threejs-ex/WebGL',[],function () {\r\n    'use strict';\r\n    var WEBGL = {\r\n        isWebGLAvailable: function () {\r\n            try {\r\n                var canvas = document.createElement('canvas');\r\n                return !!(window.WebGLRenderingContext && (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));\r\n            } catch (e) {\r\n                return false;\r\n            }\r\n        },\r\n        isWebGL2Available: function () {\r\n            try {\r\n                var canvas = document.createElement('canvas');\r\n                return !!(window.WebGL2RenderingContext && canvas.getContext('webgl2'));\r\n            } catch (e) {\r\n                return false;\r\n            }\r\n        },\r\n        getWebGLErrorMessage: function () {\r\n            return this.getErrorMessage(1);\r\n        },\r\n        getWebGL2ErrorMessage: function () {\r\n            return this.getErrorMessage(2);\r\n        },\r\n        getErrorMessage: function (version) {\r\n            var names = {\r\n                1: 'WebGL',\r\n                2: 'WebGL 2'\r\n            };\r\n            var contexts = {\r\n                1: window.WebGLRenderingContext,\r\n                2: window.WebGL2RenderingContext\r\n            };\r\n            var message = 'Your $0 does not seem to support <a href=\"http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation\" style=\"color:#000\">$1</a>';\r\n            var element = document.createElement('div');\r\n            element.id = 'webglmessage';\r\n            element.style.fontFamily = 'monospace';\r\n            element.style.fontSize = '13px';\r\n            element.style.fontWeight = 'normal';\r\n            element.style.textAlign = 'center';\r\n            element.style.background = '#fff';\r\n            element.style.color = '#000';\r\n            element.style.padding = '1.5em';\r\n            element.style.width = '400px';\r\n            element.style.margin = '5em auto 0';\r\n            if (contexts[version]) {\r\n                message = message.replace('$0', 'graphics card');\r\n            } else {\r\n                message = message.replace('$0', 'browser');\r\n            }\r\n            message = message.replace('$1', names[version]);\r\n            element.innerHTML = message;\r\n            return element;\r\n        }\r\n    };\r\n    return WEBGL;\r\n});\ndefine('skylark-threejs-ex/utils/stats',[],function(){\r\n\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\r\n\tvar Stats = function () {\r\n\r\n\t\tvar mode = 0;\r\n\r\n\t\tvar container = document.createElement( 'div' );\r\n\t\tcontainer.style.cssText = 'position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000';\r\n\t\tcontainer.addEventListener( 'click', function ( event ) {\r\n\r\n\t\t\tevent.preventDefault();\r\n\t\t\tshowPanel( ++ mode % container.children.length );\r\n\r\n\t\t}, false );\r\n\r\n\t\t//\r\n\r\n\t\tfunction addPanel( panel ) {\r\n\r\n\t\t\tcontainer.appendChild( panel.dom );\r\n\t\t\treturn panel;\r\n\r\n\t\t}\r\n\r\n\t\tfunction showPanel( id ) {\r\n\r\n\t\t\tfor ( var i = 0; i < container.children.length; i ++ ) {\r\n\r\n\t\t\t\tcontainer.children[ i ].style.display = i === id ? 'block' : 'none';\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmode = id;\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tvar beginTime = ( performance || Date ).now(), prevTime = beginTime, frames = 0;\r\n\r\n\t\tvar fpsPanel = addPanel( new Stats.Panel( 'FPS', '#0ff', '#002' ) );\r\n\t\tvar msPanel = addPanel( new Stats.Panel( 'MS', '#0f0', '#020' ) );\r\n\r\n\t\tif ( self.performance && self.performance.memory ) {\r\n\r\n\t\t\tvar memPanel = addPanel( new Stats.Panel( 'MB', '#f08', '#201' ) );\r\n\r\n\t\t}\r\n\r\n\t\tshowPanel( 0 );\r\n\r\n\t\treturn {\r\n\r\n\t\t\tREVISION: 16,\r\n\r\n\t\t\tdom: container,\r\n\r\n\t\t\taddPanel: addPanel,\r\n\t\t\tshowPanel: showPanel,\r\n\r\n\t\t\tbegin: function () {\r\n\r\n\t\t\t\tbeginTime = ( performance || Date ).now();\r\n\r\n\t\t\t},\r\n\r\n\t\t\tend: function () {\r\n\r\n\t\t\t\tframes ++;\r\n\r\n\t\t\t\tvar time = ( performance || Date ).now();\r\n\r\n\t\t\t\tmsPanel.update( time - beginTime, 200 );\r\n\r\n\t\t\t\tif ( time >= prevTime + 1000 ) {\r\n\r\n\t\t\t\t\tfpsPanel.update( ( frames * 1000 ) / ( time - prevTime ), 100 );\r\n\r\n\t\t\t\t\tprevTime = time;\r\n\t\t\t\t\tframes = 0;\r\n\r\n\t\t\t\t\tif ( memPanel ) {\r\n\r\n\t\t\t\t\t\tvar memory = performance.memory;\r\n\t\t\t\t\t\tmemPanel.update( memory.usedJSHeapSize / 1048576, memory.jsHeapSizeLimit / 1048576 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn time;\r\n\r\n\t\t\t},\r\n\r\n\t\t\tupdate: function () {\r\n\r\n\t\t\t\tbeginTime = this.end();\r\n\r\n\t\t\t},\r\n\r\n\t\t\t// Backwards Compatibility\r\n\r\n\t\t\tdomElement: container,\r\n\t\t\tsetMode: showPanel\r\n\r\n\t\t};\r\n\r\n\t};\r\n\r\n\tStats.Panel = function ( name, fg, bg ) {\r\n\r\n\t\tvar min = Infinity, max = 0, round = Math.round;\r\n\t\tvar PR = round( window.devicePixelRatio || 1 );\r\n\r\n\t\tvar WIDTH = 80 * PR, HEIGHT = 48 * PR,\r\n\t\t\t\tTEXT_X = 3 * PR, TEXT_Y = 2 * PR,\r\n\t\t\t\tGRAPH_X = 3 * PR, GRAPH_Y = 15 * PR,\r\n\t\t\t\tGRAPH_WIDTH = 74 * PR, GRAPH_HEIGHT = 30 * PR;\r\n\r\n\t\tvar canvas = document.createElement( 'canvas' );\r\n\t\tcanvas.width = WIDTH;\r\n\t\tcanvas.height = HEIGHT;\r\n\t\tcanvas.style.cssText = 'width:80px;height:48px';\r\n\r\n\t\tvar context = canvas.getContext( '2d' );\r\n\t\tcontext.font = 'bold ' + ( 9 * PR ) + 'px Helvetica,Arial,sans-serif';\r\n\t\tcontext.textBaseline = 'top';\r\n\r\n\t\tcontext.fillStyle = bg;\r\n\t\tcontext.fillRect( 0, 0, WIDTH, HEIGHT );\r\n\r\n\t\tcontext.fillStyle = fg;\r\n\t\tcontext.fillText( name, TEXT_X, TEXT_Y );\r\n\t\tcontext.fillRect( GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT );\r\n\r\n\t\tcontext.fillStyle = bg;\r\n\t\tcontext.globalAlpha = 0.9;\r\n\t\tcontext.fillRect( GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT );\r\n\r\n\t\treturn {\r\n\r\n\t\t\tdom: canvas,\r\n\r\n\t\t\tupdate: function ( value, maxValue ) {\r\n\r\n\t\t\t\tmin = Math.min( min, value );\r\n\t\t\t\tmax = Math.max( max, value );\r\n\r\n\t\t\t\tcontext.fillStyle = bg;\r\n\t\t\t\tcontext.globalAlpha = 1;\r\n\t\t\t\tcontext.fillRect( 0, 0, WIDTH, GRAPH_Y );\r\n\t\t\t\tcontext.fillStyle = fg;\r\n\t\t\t\tcontext.fillText( round( value ) + ' ' + name + ' (' + round( min ) + '-' + round( max ) + ')', TEXT_X, TEXT_Y );\r\n\r\n\t\t\t\tcontext.drawImage( canvas, GRAPH_X + PR, GRAPH_Y, GRAPH_WIDTH - PR, GRAPH_HEIGHT, GRAPH_X, GRAPH_Y, GRAPH_WIDTH - PR, GRAPH_HEIGHT );\r\n\r\n\t\t\t\tcontext.fillRect( GRAPH_X + GRAPH_WIDTH - PR, GRAPH_Y, PR, GRAPH_HEIGHT );\r\n\r\n\t\t\t\tcontext.fillStyle = bg;\r\n\t\t\t\tcontext.globalAlpha = 0.9;\r\n\t\t\t\tcontext.fillRect( GRAPH_X + GRAPH_WIDTH - PR, GRAPH_Y, PR, round( ( 1 - ( value / maxValue ) ) * GRAPH_HEIGHT ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t};\r\n\r\n\treturn  Stats;\r\n\r\n});\r\n\ndefine('skylark-threejs-ex/controls/OrbitControls',[\r\n    \"skylark-threejs\"\r\n], function (THREE) {\r\n    'use strict';\r\n    var OrbitControls = function (object, domElement) {\r\n        if (domElement === undefined)\r\n            console.warn('THREE.OrbitControls: The second parameter \"domElement\" is now mandatory.');\r\n        if (domElement === document)\r\n            console.error('THREE.OrbitControls: \"document\" should not be used as the target \"domElement\". Please use \"renderer.domElement\" instead.');\r\n        this.object = object;\r\n        this.domElement = domElement;\r\n        this.enabled = true;\r\n        this.target = new THREE.Vector3();\r\n        this.minDistance = 0;\r\n        this.maxDistance = Infinity;\r\n        this.minZoom = 0;\r\n        this.maxZoom = Infinity;\r\n        this.minPolarAngle = 0;\r\n        this.maxPolarAngle = Math.PI;\r\n        this.minAzimuthAngle = -Infinity;\r\n        this.maxAzimuthAngle = Infinity;\r\n        this.enableDamping = false;\r\n        this.dampingFactor = 0.05;\r\n        this.enableZoom = true;\r\n        this.zoomSpeed = 1;\r\n        this.enableRotate = true;\r\n        this.rotateSpeed = 1;\r\n        this.enablePan = true;\r\n        this.panSpeed = 1;\r\n        this.screenSpacePanning = false;\r\n        this.keyPanSpeed = 7;\r\n        this.autoRotate = false;\r\n        this.autoRotateSpeed = 2;\r\n        this.enableKeys = true;\r\n        this.keys = {\r\n            LEFT: 37,\r\n            UP: 38,\r\n            RIGHT: 39,\r\n            BOTTOM: 40\r\n        };\r\n        this.mouseButtons = {\r\n            LEFT: THREE.MOUSE.ROTATE,\r\n            MIDDLE: THREE.MOUSE.DOLLY,\r\n            RIGHT: THREE.MOUSE.PAN\r\n        };\r\n        this.touches = {\r\n            ONE: THREE.TOUCH.ROTATE,\r\n            TWO: THREE.TOUCH.DOLLY_PAN\r\n        };\r\n        this.target0 = this.target.clone();\r\n        this.position0 = this.object.position.clone();\r\n        this.zoom0 = this.object.zoom;\r\n        this.getPolarAngle = function () {\r\n            return spherical.phi;\r\n        };\r\n        this.getAzimuthalAngle = function () {\r\n            return spherical.theta;\r\n        };\r\n        this.saveState = function () {\r\n            scope.target0.copy(scope.target);\r\n            scope.position0.copy(scope.object.position);\r\n            scope.zoom0 = scope.object.zoom;\r\n        };\r\n        this.reset = function () {\r\n            scope.target.copy(scope.target0);\r\n            scope.object.position.copy(scope.position0);\r\n            scope.object.zoom = scope.zoom0;\r\n            scope.object.updateProjectionMatrix();\r\n            scope.dispatchEvent(changeEvent);\r\n            scope.update();\r\n            state = STATE.NONE;\r\n        };\r\n        this.update = function () {\r\n            var offset = new THREE.Vector3();\r\n            var quat = new THREE.Quaternion().setFromUnitVectors(object.up, new THREE.Vector3(0, 1, 0));\r\n            var quatInverse = quat.clone().inverse();\r\n            var lastPosition = new THREE.Vector3();\r\n            var lastQuaternion = new THREE.Quaternion();\r\n            return function update() {\r\n                var position = scope.object.position;\r\n                offset.copy(position).sub(scope.target);\r\n                offset.applyQuaternion(quat);\r\n                spherical.setFromVector3(offset);\r\n                if (scope.autoRotate && state === STATE.NONE) {\r\n                    rotateLeft(getAutoRotationAngle());\r\n                }\r\n                if (scope.enableDamping) {\r\n                    spherical.theta += sphericalDelta.theta * scope.dampingFactor;\r\n                    spherical.phi += sphericalDelta.phi * scope.dampingFactor;\r\n                } else {\r\n                    spherical.theta += sphericalDelta.theta;\r\n                    spherical.phi += sphericalDelta.phi;\r\n                }\r\n                spherical.theta = Math.max(scope.minAzimuthAngle, Math.min(scope.maxAzimuthAngle, spherical.theta));\r\n                spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));\r\n                spherical.makeSafe();\r\n                spherical.radius *= scale;\r\n                spherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius));\r\n                if (scope.enableDamping === true) {\r\n                    scope.target.addScaledVector(panOffset, scope.dampingFactor);\r\n                } else {\r\n                    scope.target.add(panOffset);\r\n                }\r\n                offset.setFromSpherical(spherical);\r\n                offset.applyQuaternion(quatInverse);\r\n                position.copy(scope.target).add(offset);\r\n                scope.object.lookAt(scope.target);\r\n                if (scope.enableDamping === true) {\r\n                    sphericalDelta.theta *= 1 - scope.dampingFactor;\r\n                    sphericalDelta.phi *= 1 - scope.dampingFactor;\r\n                    panOffset.multiplyScalar(1 - scope.dampingFactor);\r\n                } else {\r\n                    sphericalDelta.set(0, 0, 0);\r\n                    panOffset.set(0, 0, 0);\r\n                }\r\n                scale = 1;\r\n                if (zoomChanged || lastPosition.distanceToSquared(scope.object.position) > EPS || 8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS) {\r\n                    scope.dispatchEvent(changeEvent);\r\n                    lastPosition.copy(scope.object.position);\r\n                    lastQuaternion.copy(scope.object.quaternion);\r\n                    zoomChanged = false;\r\n                    return true;\r\n                }\r\n                return false;\r\n            };\r\n        }();\r\n        this.dispose = function () {\r\n            scope.domElement.removeEventListener('contextmenu', onContextMenu, false);\r\n            scope.domElement.removeEventListener('mousedown', onMouseDown, false);\r\n            scope.domElement.removeEventListener('wheel', onMouseWheel, false);\r\n            scope.domElement.removeEventListener('touchstart', onTouchStart, false);\r\n            scope.domElement.removeEventListener('touchend', onTouchEnd, false);\r\n            scope.domElement.removeEventListener('touchmove', onTouchMove, false);\r\n            document.removeEventListener('mousemove', onMouseMove, false);\r\n            document.removeEventListener('mouseup', onMouseUp, false);\r\n            scope.domElement.removeEventListener('keydown', onKeyDown, false);\r\n        };\r\n        var scope = this;\r\n        var changeEvent = { type: 'change' };\r\n        var startEvent = { type: 'start' };\r\n        var endEvent = { type: 'end' };\r\n        var STATE = {\r\n            NONE: -1,\r\n            ROTATE: 0,\r\n            DOLLY: 1,\r\n            PAN: 2,\r\n            TOUCH_ROTATE: 3,\r\n            TOUCH_PAN: 4,\r\n            TOUCH_DOLLY_PAN: 5,\r\n            TOUCH_DOLLY_ROTATE: 6\r\n        };\r\n        var state = STATE.NONE;\r\n        var EPS = 0.000001;\r\n        var spherical = new THREE.Spherical();\r\n        var sphericalDelta = new THREE.Spherical();\r\n        var scale = 1;\r\n        var panOffset = new THREE.Vector3();\r\n        var zoomChanged = false;\r\n        var rotateStart = new THREE.Vector2();\r\n        var rotateEnd = new THREE.Vector2();\r\n        var rotateDelta = new THREE.Vector2();\r\n        var panStart = new THREE.Vector2();\r\n        var panEnd = new THREE.Vector2();\r\n        var panDelta = new THREE.Vector2();\r\n        var dollyStart = new THREE.Vector2();\r\n        var dollyEnd = new THREE.Vector2();\r\n        var dollyDelta = new THREE.Vector2();\r\n        function getAutoRotationAngle() {\r\n            return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\r\n        }\r\n        function getZoomScale() {\r\n            return Math.pow(0.95, scope.zoomSpeed);\r\n        }\r\n        function rotateLeft(angle) {\r\n            sphericalDelta.theta -= angle;\r\n        }\r\n        function rotateUp(angle) {\r\n            sphericalDelta.phi -= angle;\r\n        }\r\n        var panLeft = function () {\r\n            var v = new THREE.Vector3();\r\n            return function panLeft(distance, objectMatrix) {\r\n                v.setFromMatrixColumn(objectMatrix, 0);\r\n                v.multiplyScalar(-distance);\r\n                panOffset.add(v);\r\n            };\r\n        }();\r\n        var panUp = function () {\r\n            var v = new THREE.Vector3();\r\n            return function panUp(distance, objectMatrix) {\r\n                if (scope.screenSpacePanning === true) {\r\n                    v.setFromMatrixColumn(objectMatrix, 1);\r\n                } else {\r\n                    v.setFromMatrixColumn(objectMatrix, 0);\r\n                    v.crossVectors(scope.object.up, v);\r\n                }\r\n                v.multiplyScalar(distance);\r\n                panOffset.add(v);\r\n            };\r\n        }();\r\n        var pan = function () {\r\n            var offset = new THREE.Vector3();\r\n            return function pan(deltaX, deltaY) {\r\n                var element = scope.domElement;\r\n                if (scope.object.isPerspectiveCamera) {\r\n                    var position = scope.object.position;\r\n                    offset.copy(position).sub(scope.target);\r\n                    var targetDistance = offset.length();\r\n                    targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180);\r\n                    panLeft(2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix);\r\n                    panUp(2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix);\r\n                } else if (scope.object.isOrthographicCamera) {\r\n                    panLeft(deltaX * (scope.object.right - scope.object.left) / scope.object.zoom / element.clientWidth, scope.object.matrix);\r\n                    panUp(deltaY * (scope.object.top - scope.object.bottom) / scope.object.zoom / element.clientHeight, scope.object.matrix);\r\n                } else {\r\n                    console.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.');\r\n                    scope.enablePan = false;\r\n                }\r\n            };\r\n        }();\r\n        function dollyOut(dollyScale) {\r\n            if (scope.object.isPerspectiveCamera) {\r\n                scale /= dollyScale;\r\n            } else if (scope.object.isOrthographicCamera) {\r\n                scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom * dollyScale));\r\n                scope.object.updateProjectionMatrix();\r\n                zoomChanged = true;\r\n            } else {\r\n                console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');\r\n                scope.enableZoom = false;\r\n            }\r\n        }\r\n        function dollyIn(dollyScale) {\r\n            if (scope.object.isPerspectiveCamera) {\r\n                scale *= dollyScale;\r\n            } else if (scope.object.isOrthographicCamera) {\r\n                scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / dollyScale));\r\n                scope.object.updateProjectionMatrix();\r\n                zoomChanged = true;\r\n            } else {\r\n                console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');\r\n                scope.enableZoom = false;\r\n            }\r\n        }\r\n        function handleMouseDownRotate(event) {\r\n            rotateStart.set(event.clientX, event.clientY);\r\n        }\r\n        function handleMouseDownDolly(event) {\r\n            dollyStart.set(event.clientX, event.clientY);\r\n        }\r\n        function handleMouseDownPan(event) {\r\n            panStart.set(event.clientX, event.clientY);\r\n        }\r\n        function handleMouseMoveRotate(event) {\r\n            rotateEnd.set(event.clientX, event.clientY);\r\n            rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);\r\n            var element = scope.domElement;\r\n            rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight);\r\n            rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);\r\n            rotateStart.copy(rotateEnd);\r\n            scope.update();\r\n        }\r\n        function handleMouseMoveDolly(event) {\r\n            dollyEnd.set(event.clientX, event.clientY);\r\n            dollyDelta.subVectors(dollyEnd, dollyStart);\r\n            if (dollyDelta.y > 0) {\r\n                dollyOut(getZoomScale());\r\n            } else if (dollyDelta.y < 0) {\r\n                dollyIn(getZoomScale());\r\n            }\r\n            dollyStart.copy(dollyEnd);\r\n            scope.update();\r\n        }\r\n        function handleMouseMovePan(event) {\r\n            panEnd.set(event.clientX, event.clientY);\r\n            panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);\r\n            pan(panDelta.x, panDelta.y);\r\n            panStart.copy(panEnd);\r\n            scope.update();\r\n        }\r\n        function handleMouseUp() {\r\n        }\r\n        function handleMouseWheel(event) {\r\n            if (event.deltaY < 0) {\r\n                dollyIn(getZoomScale());\r\n            } else if (event.deltaY > 0) {\r\n                dollyOut(getZoomScale());\r\n            }\r\n            scope.update();\r\n        }\r\n        function handleKeyDown(event) {\r\n            var needsUpdate = false;\r\n            switch (event.keyCode) {\r\n            case scope.keys.UP:\r\n                pan(0, scope.keyPanSpeed);\r\n                needsUpdate = true;\r\n                break;\r\n            case scope.keys.BOTTOM:\r\n                pan(0, -scope.keyPanSpeed);\r\n                needsUpdate = true;\r\n                break;\r\n            case scope.keys.LEFT:\r\n                pan(scope.keyPanSpeed, 0);\r\n                needsUpdate = true;\r\n                break;\r\n            case scope.keys.RIGHT:\r\n                pan(-scope.keyPanSpeed, 0);\r\n                needsUpdate = true;\r\n                break;\r\n            }\r\n            if (needsUpdate) {\r\n                event.preventDefault();\r\n                scope.update();\r\n            }\r\n        }\r\n        function handleTouchStartRotate(event) {\r\n            if (event.touches.length == 1) {\r\n                rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);\r\n            } else {\r\n                var x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);\r\n                var y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);\r\n                rotateStart.set(x, y);\r\n            }\r\n        }\r\n        function handleTouchStartPan(event) {\r\n            if (event.touches.length == 1) {\r\n                panStart.set(event.touches[0].pageX, event.touches[0].pageY);\r\n            } else {\r\n                var x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);\r\n                var y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);\r\n                panStart.set(x, y);\r\n            }\r\n        }\r\n        function handleTouchStartDolly(event) {\r\n            var dx = event.touches[0].pageX - event.touches[1].pageX;\r\n            var dy = event.touches[0].pageY - event.touches[1].pageY;\r\n            var distance = Math.sqrt(dx * dx + dy * dy);\r\n            dollyStart.set(0, distance);\r\n        }\r\n        function handleTouchStartDollyPan(event) {\r\n            if (scope.enableZoom)\r\n                handleTouchStartDolly(event);\r\n            if (scope.enablePan)\r\n                handleTouchStartPan(event);\r\n        }\r\n        function handleTouchStartDollyRotate(event) {\r\n            if (scope.enableZoom)\r\n                handleTouchStartDolly(event);\r\n            if (scope.enableRotate)\r\n                handleTouchStartRotate(event);\r\n        }\r\n        function handleTouchMoveRotate(event) {\r\n            if (event.touches.length == 1) {\r\n                rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);\r\n            } else {\r\n                var x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);\r\n                var y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);\r\n                rotateEnd.set(x, y);\r\n            }\r\n            rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);\r\n            var element = scope.domElement;\r\n            rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight);\r\n            rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);\r\n            rotateStart.copy(rotateEnd);\r\n        }\r\n        function handleTouchMovePan(event) {\r\n            if (event.touches.length == 1) {\r\n                panEnd.set(event.touches[0].pageX, event.touches[0].pageY);\r\n            } else {\r\n                var x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);\r\n                var y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);\r\n                panEnd.set(x, y);\r\n            }\r\n            panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);\r\n            pan(panDelta.x, panDelta.y);\r\n            panStart.copy(panEnd);\r\n        }\r\n        function handleTouchMoveDolly(event) {\r\n            var dx = event.touches[0].pageX - event.touches[1].pageX;\r\n            var dy = event.touches[0].pageY - event.touches[1].pageY;\r\n            var distance = Math.sqrt(dx * dx + dy * dy);\r\n            dollyEnd.set(0, distance);\r\n            dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed));\r\n            dollyOut(dollyDelta.y);\r\n            dollyStart.copy(dollyEnd);\r\n        }\r\n        function handleTouchMoveDollyPan(event) {\r\n            if (scope.enableZoom)\r\n                handleTouchMoveDolly(event);\r\n            if (scope.enablePan)\r\n                handleTouchMovePan(event);\r\n        }\r\n        function handleTouchMoveDollyRotate(event) {\r\n            if (scope.enableZoom)\r\n                handleTouchMoveDolly(event);\r\n            if (scope.enableRotate)\r\n                handleTouchMoveRotate(event);\r\n        }\r\n        function handleTouchEnd() {\r\n        }\r\n        function onMouseDown(event) {\r\n            if (scope.enabled === false)\r\n                return;\r\n            event.preventDefault();\r\n            scope.domElement.focus ? scope.domElement.focus() : window.focus();\r\n            var mouseAction;\r\n            switch (event.button) {\r\n            case 0:\r\n                mouseAction = scope.mouseButtons.LEFT;\r\n                break;\r\n            case 1:\r\n                mouseAction = scope.mouseButtons.MIDDLE;\r\n                break;\r\n            case 2:\r\n                mouseAction = scope.mouseButtons.RIGHT;\r\n                break;\r\n            default:\r\n                mouseAction = -1;\r\n            }\r\n            switch (mouseAction) {\r\n            case THREE.MOUSE.DOLLY:\r\n                if (scope.enableZoom === false)\r\n                    return;\r\n                handleMouseDownDolly(event);\r\n                state = STATE.DOLLY;\r\n                break;\r\n            case THREE.MOUSE.ROTATE:\r\n                if (event.ctrlKey || event.metaKey || event.shiftKey) {\r\n                    if (scope.enablePan === false)\r\n                        return;\r\n                    handleMouseDownPan(event);\r\n                    state = STATE.PAN;\r\n                } else {\r\n                    if (scope.enableRotate === false)\r\n                        return;\r\n                    handleMouseDownRotate(event);\r\n                    state = STATE.ROTATE;\r\n                }\r\n                break;\r\n            case THREE.MOUSE.PAN:\r\n                if (event.ctrlKey || event.metaKey || event.shiftKey) {\r\n                    if (scope.enableRotate === false)\r\n                        return;\r\n                    handleMouseDownRotate(event);\r\n                    state = STATE.ROTATE;\r\n                } else {\r\n                    if (scope.enablePan === false)\r\n                        return;\r\n                    handleMouseDownPan(event);\r\n                    state = STATE.PAN;\r\n                }\r\n                break;\r\n            default:\r\n                state = STATE.NONE;\r\n            }\r\n            if (state !== STATE.NONE) {\r\n                document.addEventListener('mousemove', onMouseMove, false);\r\n                document.addEventListener('mouseup', onMouseUp, false);\r\n                scope.dispatchEvent(startEvent);\r\n            }\r\n        }\r\n        function onMouseMove(event) {\r\n            if (scope.enabled === false)\r\n                return;\r\n            event.preventDefault();\r\n            switch (state) {\r\n            case STATE.ROTATE:\r\n                if (scope.enableRotate === false)\r\n                    return;\r\n                handleMouseMoveRotate(event);\r\n                break;\r\n            case STATE.DOLLY:\r\n                if (scope.enableZoom === false)\r\n                    return;\r\n                handleMouseMoveDolly(event);\r\n                break;\r\n            case STATE.PAN:\r\n                if (scope.enablePan === false)\r\n                    return;\r\n                handleMouseMovePan(event);\r\n                break;\r\n            }\r\n        }\r\n        function onMouseUp(event) {\r\n            if (scope.enabled === false)\r\n                return;\r\n            handleMouseUp(event);\r\n            document.removeEventListener('mousemove', onMouseMove, false);\r\n            document.removeEventListener('mouseup', onMouseUp, false);\r\n            scope.dispatchEvent(endEvent);\r\n            state = STATE.NONE;\r\n        }\r\n        function onMouseWheel(event) {\r\n            if (scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE && state !== STATE.ROTATE)\r\n                return;\r\n            event.preventDefault();\r\n            event.stopPropagation();\r\n            scope.dispatchEvent(startEvent);\r\n            handleMouseWheel(event);\r\n            scope.dispatchEvent(endEvent);\r\n        }\r\n        function onKeyDown(event) {\r\n            if (scope.enabled === false || scope.enableKeys === false || scope.enablePan === false)\r\n                return;\r\n            handleKeyDown(event);\r\n        }\r\n        function onTouchStart(event) {\r\n            if (scope.enabled === false)\r\n                return;\r\n            event.preventDefault();\r\n            switch (event.touches.length) {\r\n            case 1:\r\n                switch (scope.touches.ONE) {\r\n                case THREE.TOUCH.ROTATE:\r\n                    if (scope.enableRotate === false)\r\n                        return;\r\n                    handleTouchStartRotate(event);\r\n                    state = STATE.TOUCH_ROTATE;\r\n                    break;\r\n                case THREE.TOUCH.PAN:\r\n                    if (scope.enablePan === false)\r\n                        return;\r\n                    handleTouchStartPan(event);\r\n                    state = STATE.TOUCH_PAN;\r\n                    break;\r\n                default:\r\n                    state = STATE.NONE;\r\n                }\r\n                break;\r\n            case 2:\r\n                switch (scope.touches.TWO) {\r\n                case THREE.TOUCH.DOLLY_PAN:\r\n                    if (scope.enableZoom === false && scope.enablePan === false)\r\n                        return;\r\n                    handleTouchStartDollyPan(event);\r\n                    state = STATE.TOUCH_DOLLY_PAN;\r\n                    break;\r\n                case THREE.TOUCH.DOLLY_ROTATE:\r\n                    if (scope.enableZoom === false && scope.enableRotate === false)\r\n                        return;\r\n                    handleTouchStartDollyRotate(event);\r\n                    state = STATE.TOUCH_DOLLY_ROTATE;\r\n                    break;\r\n                default:\r\n                    state = STATE.NONE;\r\n                }\r\n                break;\r\n            default:\r\n                state = STATE.NONE;\r\n            }\r\n            if (state !== STATE.NONE) {\r\n                scope.dispatchEvent(startEvent);\r\n            }\r\n        }\r\n        function onTouchMove(event) {\r\n            if (scope.enabled === false)\r\n                return;\r\n            event.preventDefault();\r\n            event.stopPropagation();\r\n            switch (state) {\r\n            case STATE.TOUCH_ROTATE:\r\n                if (scope.enableRotate === false)\r\n                    return;\r\n                handleTouchMoveRotate(event);\r\n                scope.update();\r\n                break;\r\n            case STATE.TOUCH_PAN:\r\n                if (scope.enablePan === false)\r\n                    return;\r\n                handleTouchMovePan(event);\r\n                scope.update();\r\n                break;\r\n            case STATE.TOUCH_DOLLY_PAN:\r\n                if (scope.enableZoom === false && scope.enablePan === false)\r\n                    return;\r\n                handleTouchMoveDollyPan(event);\r\n                scope.update();\r\n                break;\r\n            case STATE.TOUCH_DOLLY_ROTATE:\r\n                if (scope.enableZoom === false && scope.enableRotate === false)\r\n                    return;\r\n                handleTouchMoveDollyRotate(event);\r\n                scope.update();\r\n                break;\r\n            default:\r\n                state = STATE.NONE;\r\n            }\r\n        }\r\n        function onTouchEnd(event) {\r\n            if (scope.enabled === false)\r\n                return;\r\n            handleTouchEnd(event);\r\n            scope.dispatchEvent(endEvent);\r\n            state = STATE.NONE;\r\n        }\r\n        function onContextMenu(event) {\r\n            if (scope.enabled === false)\r\n                return;\r\n            event.preventDefault();\r\n        }\r\n        scope.domElement.addEventListener('contextmenu', onContextMenu, false);\r\n        scope.domElement.addEventListener('mousedown', onMouseDown, false);\r\n        scope.domElement.addEventListener('wheel', onMouseWheel, false);\r\n        scope.domElement.addEventListener('touchstart', onTouchStart, false);\r\n        scope.domElement.addEventListener('touchend', onTouchEnd, false);\r\n        scope.domElement.addEventListener('touchmove', onTouchMove, false);\r\n        scope.domElement.addEventListener('keydown', onKeyDown, false);\r\n        if (scope.domElement.tabIndex === -1) {\r\n            scope.domElement.tabIndex = 0;\r\n        }\r\n        this.update();\r\n    };\r\n    OrbitControls.prototype = Object.create(THREE.EventDispatcher.prototype);\r\n    OrbitControls.prototype.constructor = OrbitControls;\r\n\r\n    \r\n    return     OrbitControls;\r\n});\ndefine('skylark-threejs-ex/loaders/RGBELoader',[\r\n    \"skylark-threejs\"\r\n], function (THREE) {\r\n    'use strict';\r\n    var RGBELoader = function (manager) {\r\n        THREE.DataTextureLoader.call(this, manager);\r\n        this.type = THREE.UnsignedByteType;\r\n    };\r\n    RGBELoader.prototype = Object.assign(Object.create(THREE.DataTextureLoader.prototype), {\r\n        constructor: RGBELoader,\r\n        parse: function (buffer) {\r\n            var RGBE_RETURN_FAILURE = -1, rgbe_read_error = 1, rgbe_write_error = 2, rgbe_format_error = 3, rgbe_memory_error = 4, rgbe_error = function (rgbe_error_code, msg) {\r\n                    switch (rgbe_error_code) {\r\n                    case rgbe_read_error:\r\n                        console.error('RGBELoader Read Error: ' + (msg || ''));\r\n                        break;\r\n                    case rgbe_write_error:\r\n                        console.error('RGBELoader Write Error: ' + (msg || ''));\r\n                        break;\r\n                    case rgbe_format_error:\r\n                        console.error('RGBELoader Bad File Format: ' + (msg || ''));\r\n                        break;\r\n                    default:\r\n                    case rgbe_memory_error:\r\n                        console.error('RGBELoader: Error: ' + (msg || ''));\r\n                    }\r\n                    return RGBE_RETURN_FAILURE;\r\n                }, RGBE_VALID_PROGRAMTYPE = 1, RGBE_VALID_FORMAT = 2, RGBE_VALID_DIMENSIONS = 4, NEWLINE = '\\n', fgets = function (buffer, lineLimit, consume) {\r\n                    lineLimit = !lineLimit ? 1024 : lineLimit;\r\n                    var p = buffer.pos, i = -1, len = 0, s = '', chunkSize = 128, chunk = String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)));\r\n                    while (0 > (i = chunk.indexOf(NEWLINE)) && len < lineLimit && p < buffer.byteLength) {\r\n                        s += chunk;\r\n                        len += chunk.length;\r\n                        p += chunkSize;\r\n                        chunk += String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)));\r\n                    }\r\n                    if (-1 < i) {\r\n                        if (false !== consume)\r\n                            buffer.pos += len + i + 1;\r\n                        return s + chunk.slice(0, i);\r\n                    }\r\n                    return false;\r\n                }, RGBE_ReadHeader = function (buffer) {\r\n                    var line, match, magic_token_re = /^#\\?(\\S+)$/, gamma_re = /^\\s*GAMMA\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/, exposure_re = /^\\s*EXPOSURE\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/, format_re = /^\\s*FORMAT=(\\S+)\\s*$/, dimensions_re = /^\\s*\\-Y\\s+(\\d+)\\s+\\+X\\s+(\\d+)\\s*$/, header = {\r\n                            valid: 0,\r\n                            string: '',\r\n                            comments: '',\r\n                            programtype: 'RGBE',\r\n                            format: '',\r\n                            gamma: 1,\r\n                            exposure: 1,\r\n                            width: 0,\r\n                            height: 0\r\n                        };\r\n                    if (buffer.pos >= buffer.byteLength || !(line = fgets(buffer))) {\r\n                        return rgbe_error(rgbe_read_error, 'no header found');\r\n                    }\r\n                    if (!(match = line.match(magic_token_re))) {\r\n                        return rgbe_error(rgbe_format_error, 'bad initial token');\r\n                    }\r\n                    header.valid |= RGBE_VALID_PROGRAMTYPE;\r\n                    header.programtype = match[1];\r\n                    header.string += line + '\\n';\r\n                    while (true) {\r\n                        line = fgets(buffer);\r\n                        if (false === line)\r\n                            break;\r\n                        header.string += line + '\\n';\r\n                        if ('#' === line.charAt(0)) {\r\n                            header.comments += line + '\\n';\r\n                            continue;\r\n                        }\r\n                        if (match = line.match(gamma_re)) {\r\n                            header.gamma = parseFloat(match[1], 10);\r\n                        }\r\n                        if (match = line.match(exposure_re)) {\r\n                            header.exposure = parseFloat(match[1], 10);\r\n                        }\r\n                        if (match = line.match(format_re)) {\r\n                            header.valid |= RGBE_VALID_FORMAT;\r\n                            header.format = match[1];\r\n                        }\r\n                        if (match = line.match(dimensions_re)) {\r\n                            header.valid |= RGBE_VALID_DIMENSIONS;\r\n                            header.height = parseInt(match[1], 10);\r\n                            header.width = parseInt(match[2], 10);\r\n                        }\r\n                        if (header.valid & RGBE_VALID_FORMAT && header.valid & RGBE_VALID_DIMENSIONS)\r\n                            break;\r\n                    }\r\n                    if (!(header.valid & RGBE_VALID_FORMAT)) {\r\n                        return rgbe_error(rgbe_format_error, 'missing format specifier');\r\n                    }\r\n                    if (!(header.valid & RGBE_VALID_DIMENSIONS)) {\r\n                        return rgbe_error(rgbe_format_error, 'missing image size specifier');\r\n                    }\r\n                    return header;\r\n                }, RGBE_ReadPixels_RLE = function (buffer, w, h) {\r\n                    var data_rgba, offset, pos, count, byteValue, scanline_buffer, ptr, ptr_end, i, l, off, isEncodedRun, scanline_width = w, num_scanlines = h, rgbeStart;\r\n                    if (scanline_width < 8 || scanline_width > 32767 || (2 !== buffer[0] || 2 !== buffer[1] || buffer[2] & 128)) {\r\n                        return new Uint8Array(buffer);\r\n                    }\r\n                    if (scanline_width !== (buffer[2] << 8 | buffer[3])) {\r\n                        return rgbe_error(rgbe_format_error, 'wrong scanline width');\r\n                    }\r\n                    data_rgba = new Uint8Array(4 * w * h);\r\n                    if (!data_rgba || !data_rgba.length) {\r\n                        return rgbe_error(rgbe_memory_error, 'unable to allocate buffer space');\r\n                    }\r\n                    offset = 0;\r\n                    pos = 0;\r\n                    ptr_end = 4 * scanline_width;\r\n                    rgbeStart = new Uint8Array(4);\r\n                    scanline_buffer = new Uint8Array(ptr_end);\r\n                    while (num_scanlines > 0 && pos < buffer.byteLength) {\r\n                        if (pos + 4 > buffer.byteLength) {\r\n                            return rgbe_error(rgbe_read_error);\r\n                        }\r\n                        rgbeStart[0] = buffer[pos++];\r\n                        rgbeStart[1] = buffer[pos++];\r\n                        rgbeStart[2] = buffer[pos++];\r\n                        rgbeStart[3] = buffer[pos++];\r\n                        if (2 != rgbeStart[0] || 2 != rgbeStart[1] || (rgbeStart[2] << 8 | rgbeStart[3]) != scanline_width) {\r\n                            return rgbe_error(rgbe_format_error, 'bad rgbe scanline format');\r\n                        }\r\n                        ptr = 0;\r\n                        while (ptr < ptr_end && pos < buffer.byteLength) {\r\n                            count = buffer[pos++];\r\n                            isEncodedRun = count > 128;\r\n                            if (isEncodedRun)\r\n                                count -= 128;\r\n                            if (0 === count || ptr + count > ptr_end) {\r\n                                return rgbe_error(rgbe_format_error, 'bad scanline data');\r\n                            }\r\n                            if (isEncodedRun) {\r\n                                byteValue = buffer[pos++];\r\n                                for (i = 0; i < count; i++) {\r\n                                    scanline_buffer[ptr++] = byteValue;\r\n                                }\r\n                            } else {\r\n                                scanline_buffer.set(buffer.subarray(pos, pos + count), ptr);\r\n                                ptr += count;\r\n                                pos += count;\r\n                            }\r\n                        }\r\n                        l = scanline_width;\r\n                        for (i = 0; i < l; i++) {\r\n                            off = 0;\r\n                            data_rgba[offset] = scanline_buffer[i + off];\r\n                            off += scanline_width;\r\n                            data_rgba[offset + 1] = scanline_buffer[i + off];\r\n                            off += scanline_width;\r\n                            data_rgba[offset + 2] = scanline_buffer[i + off];\r\n                            off += scanline_width;\r\n                            data_rgba[offset + 3] = scanline_buffer[i + off];\r\n                            offset += 4;\r\n                        }\r\n                        num_scanlines--;\r\n                    }\r\n                    return data_rgba;\r\n                };\r\n            var RGBEByteToRGBFloat = function (sourceArray, sourceOffset, destArray, destOffset) {\r\n                var e = sourceArray[sourceOffset + 3];\r\n                var scale = Math.pow(2, e - 128) / 255;\r\n                destArray[destOffset + 0] = sourceArray[sourceOffset + 0] * scale;\r\n                destArray[destOffset + 1] = sourceArray[sourceOffset + 1] * scale;\r\n                destArray[destOffset + 2] = sourceArray[sourceOffset + 2] * scale;\r\n            };\r\n            var RGBEByteToRGBHalf = function () {\r\n                var floatView = new Float32Array(1);\r\n                var int32View = new Int32Array(floatView.buffer);\r\n                function toHalf(val) {\r\n                    floatView[0] = val;\r\n                    var x = int32View[0];\r\n                    var bits = x >> 16 & 32768;\r\n                    var m = x >> 12 & 2047;\r\n                    var e = x >> 23 & 255;\r\n                    if (e < 103)\r\n                        return bits;\r\n                    if (e > 142) {\r\n                        bits |= 31744;\r\n                        bits |= (e == 255 ? 0 : 1) && x & 8388607;\r\n                        return bits;\r\n                    }\r\n                    if (e < 113) {\r\n                        m |= 2048;\r\n                        bits |= (m >> 114 - e) + (m >> 113 - e & 1);\r\n                        return bits;\r\n                    }\r\n                    bits |= e - 112 << 10 | m >> 1;\r\n                    bits += m & 1;\r\n                    return bits;\r\n                }\r\n                return function (sourceArray, sourceOffset, destArray, destOffset) {\r\n                    var e = sourceArray[sourceOffset + 3];\r\n                    var scale = Math.pow(2, e - 128) / 255;\r\n                    destArray[destOffset + 0] = toHalf(sourceArray[sourceOffset + 0] * scale);\r\n                    destArray[destOffset + 1] = toHalf(sourceArray[sourceOffset + 1] * scale);\r\n                    destArray[destOffset + 2] = toHalf(sourceArray[sourceOffset + 2] * scale);\r\n                };\r\n            }();\r\n            var byteArray = new Uint8Array(buffer);\r\n            byteArray.pos = 0;\r\n            var rgbe_header_info = RGBE_ReadHeader(byteArray);\r\n            if (RGBE_RETURN_FAILURE !== rgbe_header_info) {\r\n                var w = rgbe_header_info.width, h = rgbe_header_info.height, image_rgba_data = RGBE_ReadPixels_RLE(byteArray.subarray(byteArray.pos), w, h);\r\n                if (RGBE_RETURN_FAILURE !== image_rgba_data) {\r\n                    switch (this.type) {\r\n                    case THREE.UnsignedByteType:\r\n                        var data = image_rgba_data;\r\n                        var format = THREE.RGBEFormat;\r\n                        var type = THREE.UnsignedByteType;\r\n                        break;\r\n                    case THREE.FloatType:\r\n                        var numElements = image_rgba_data.length / 4 * 3;\r\n                        var floatArray = new Float32Array(numElements);\r\n                        for (var j = 0; j < numElements; j++) {\r\n                            RGBEByteToRGBFloat(image_rgba_data, j * 4, floatArray, j * 3);\r\n                        }\r\n                        var data = floatArray;\r\n                        var format = THREE.RGBFormat;\r\n                        var type = THREE.FloatType;\r\n                        break;\r\n                    case THREE.HalfFloatType:\r\n                        var numElements = image_rgba_data.length / 4 * 3;\r\n                        var halfArray = new Uint16Array(numElements);\r\n                        for (var j = 0; j < numElements; j++) {\r\n                            RGBEByteToRGBHalf(image_rgba_data, j * 4, halfArray, j * 3);\r\n                        }\r\n                        var data = halfArray;\r\n                        var format = THREE.RGBFormat;\r\n                        var type = THREE.HalfFloatType;\r\n                        break;\r\n                    default:\r\n                        console.error('THREE.RGBELoader: unsupported type: ', this.type);\r\n                        break;\r\n                    }\r\n                    return {\r\n                        width: w,\r\n                        height: h,\r\n                        data: data,\r\n                        header: rgbe_header_info.string,\r\n                        gamma: rgbe_header_info.gamma,\r\n                        exposure: rgbe_header_info.exposure,\r\n                        format: format,\r\n                        type: type\r\n                    };\r\n                }\r\n            }\r\n            return null;\r\n        },\r\n        setDataType: function (value) {\r\n            this.type = value;\r\n            return this;\r\n        },\r\n        load: function (url, onLoad, onProgress, onError) {\r\n            function onLoadCallback(texture, texData) {\r\n                switch (texture.type) {\r\n                case THREE.UnsignedByteType:\r\n                    texture.encoding = THREE.RGBEEncoding;\r\n                    texture.minFilter = THREE.NearestFilter;\r\n                    texture.magFilter = THREE.NearestFilter;\r\n                    texture.generateMipmaps = false;\r\n                    texture.flipY = true;\r\n                    break;\r\n                case THREE.FloatType:\r\n                    texture.encoding = THREE.LinearEncoding;\r\n                    texture.minFilter = THREE.LinearFilter;\r\n                    texture.magFilter = THREE.LinearFilter;\r\n                    texture.generateMipmaps = false;\r\n                    texture.flipY = true;\r\n                    break;\r\n                case THREE.HalfFloatType:\r\n                    texture.encoding = THREE.LinearEncoding;\r\n                    texture.minFilter = THREE.LinearFilter;\r\n                    texture.magFilter = THREE.LinearFilter;\r\n                    texture.generateMipmaps = false;\r\n                    texture.flipY = true;\r\n                    break;\r\n                }\r\n                if (onLoad)\r\n                    onLoad(texture, texData);\r\n            }\r\n            return THREE.DataTextureLoader.prototype.load.call(this, url, onLoadCallback, onProgress, onError);\r\n        }\r\n    });\r\n    return RGBELoader;\r\n});\ndefine('skylark-threegltfviewer/environments',[\r\n  \"./threegltviewer\"\r\n],function(threegltviewer){\r\n  const environments = [\r\n    {\r\n      id: '',\r\n      name: 'None',\r\n      path: null,\r\n      format: '.hdr'\r\n    },\r\n    {\r\n      id: 'venice-sunset',\r\n      name: 'Venice Sunset',\r\n      path: 'assets/environment/venice_sunset_1k.hdr',\r\n      format: '.hdr'\r\n    },\r\n    {\r\n      id: 'footprint-court',\r\n      name: 'Footprint Court (HDR Labs)',\r\n      path: 'assets/environment/footprint_court_2k.hdr',\r\n      format: '.hdr'\r\n    }\r\n  ];\r\n\r\n  return threegltviewer.environments = environments;\r\n});\r\n\r\n\ndefine('skylark-threegltfviewer/vignettes',[\r\n    'skylark-threejs',\r\n    \"./threegltviewer\"\r\n], function (THREE,threegltviewer) {\r\n    'use strict';\r\n    const vert = [\r\n                'attribute vec3 position;',\r\n                'uniform mat4 modelViewMatrix;',\r\n                'uniform mat4 projectionMatrix;',\r\n                'varying vec2 vUv;',\r\n                'void main() {',\r\n                '\\tgl_Position = vec4(position, 1.0);',\r\n                '\\tvUv = vec2(position.x, position.y) * 0.5 + 0.5;',\r\n                '}'\r\n                ].join('\\n'),\r\n          frag = [\r\n                'precision mediump float;',\r\n                '#pragma glslify: grain = require(\\'glsl-film-grain\\')',\r\n                '#pragma glslify: blend = require(\\'glsl-blend-soft-light\\')',\r\n                '',\r\n                'uniform vec3 color1;',\r\n                'uniform vec3 color2;',\r\n                'uniform float aspect;',\r\n                'uniform vec2 offset;',\r\n                'uniform vec2 scale;',\r\n                'uniform float noiseAlpha;',\r\n                'uniform bool aspectCorrection;',\r\n                'uniform float grainScale;',\r\n                'uniform float grainTime;',\r\n                'uniform vec2 smooth;',\r\n                '',\r\n                'varying vec2 vUv;',\r\n                '',\r\n                'void main() {',\r\n                '\\tvec2 q = vec2(vUv - 0.5);',\r\n                '\\tif (aspectCorrection) {',\r\n                '\\t\\tq.x *= aspect;',\r\n                '\\t}',\r\n                '\\tq /= scale;',\r\n                '\\tq -= offset;',\r\n                '\\tfloat dst = length(q);',\r\n                '\\tdst = smoothstep(smooth.x, smooth.y, dst);',\r\n                '\\tvec3 color = mix(color1, color2, dst);',\r\n                '',\r\n                '\\tif (noiseAlpha > 0.0 && grainScale > 0.0) {',\r\n                '\\t\\tfloat gSize = 1.0 / grainScale;',\r\n                '\\t\\tfloat g = grain(vUv, vec2(gSize * aspect, gSize), grainTime);',\r\n                '\\t\\tvec3 noiseColor = blend(color, vec3(g));',\r\n                '\\t\\tgl_FragColor.rgb = mix(color, noiseColor, noiseAlpha);',\r\n                '\\t} else {',\r\n                '\\t\\tgl_FragColor.rgb = color;',\r\n                '\\t}',\r\n                '\\tgl_FragColor.a = 1.0;',\r\n                '}'\r\n                ].join('\\n');\r\n\r\n    function createBackground(opt) {\r\n        opt = opt || {};\r\n        var geometry = opt.geometry || new THREE.PlaneGeometry(2, 2, 1);\r\n        var material = new THREE.RawShaderMaterial({\r\n            vertexShader: vert,\r\n            fragmentShader: frag,\r\n            side: THREE.DoubleSide,\r\n            uniforms: {\r\n                aspectCorrection: {\r\n                    type: 'i',\r\n                    value: false\r\n                },\r\n                aspect: {\r\n                    type: 'f',\r\n                    value: 1\r\n                },\r\n                grainScale: {\r\n                    type: 'f',\r\n                    value: 0.005\r\n                },\r\n                grainTime: {\r\n                    type: 'f',\r\n                    value: 0\r\n                },\r\n                noiseAlpha: {\r\n                    type: 'f',\r\n                    value: 0.25\r\n                },\r\n                offset: {\r\n                    type: 'v2',\r\n                    value: new THREE.Vector2(0, 0)\r\n                },\r\n                scale: {\r\n                    type: 'v2',\r\n                    value: new THREE.Vector2(1, 1)\r\n                },\r\n                smooth: {\r\n                    type: 'v2',\r\n                    value: new THREE.Vector2(0, 1)\r\n                },\r\n                color1: {\r\n                    type: 'c',\r\n                    value: new THREE.Color('#fff')\r\n                },\r\n                color2: {\r\n                    type: 'c',\r\n                    value: new THREE.Color('#283844')\r\n                }\r\n            },\r\n            depthTest: false\r\n        });\r\n        var mesh = new THREE.Mesh(geometry, material);\r\n        mesh.frustumCulled = false;\r\n        mesh.style = style;\r\n        if (opt)\r\n            mesh.style(opt);\r\n        return mesh;\r\n        function style(opt) {\r\n            opt = opt || {};\r\n            if (Array.isArray(opt.colors)) {\r\n                var colors = opt.colors.map(function (c) {\r\n                    if (typeof c === 'string' || typeof c === 'number') {\r\n                        return new THREE.Color(c);\r\n                    }\r\n                    return c;\r\n                });\r\n                material.uniforms.color1.value.copy(colors[0]);\r\n                material.uniforms.color2.value.copy(colors[1]);\r\n            }\r\n            if (typeof opt.aspect === 'number') {\r\n                material.uniforms.aspect.value = opt.aspect;\r\n            }\r\n            if (typeof opt.grainScale === 'number') {\r\n                material.uniforms.grainScale.value = opt.grainScale;\r\n            }\r\n            if (typeof opt.grainTime === 'number') {\r\n                material.uniforms.grainTime.value = opt.grainTime;\r\n            }\r\n            if (opt.smooth) {\r\n                var smooth = fromArray(opt.smooth, THREE.Vector2);\r\n                material.uniforms.smooth.value.copy(smooth);\r\n            }\r\n            if (opt.offset) {\r\n                var offset = fromArray(opt.offset, THREE.Vector2);\r\n                material.uniforms.offset.value.copy(offset);\r\n            }\r\n            if (typeof opt.noiseAlpha === 'number') {\r\n                material.uniforms.noiseAlpha.value = opt.noiseAlpha;\r\n            }\r\n            if (typeof opt.scale !== 'undefined') {\r\n                var scale = opt.scale;\r\n                if (typeof scale === 'number') {\r\n                    scale = [\r\n                        scale,\r\n                        scale\r\n                    ];\r\n                }\r\n                scale = fromArray(scale, THREE.Vector2);\r\n                material.uniforms.scale.value.copy(scale);\r\n            }\r\n            if (typeof opt.aspectCorrection !== 'undefined') {\r\n                material.uniforms.aspectCorrection.value = Boolean(opt.aspectCorrection);\r\n            }\r\n        }\r\n        function fromArray(array, VectorType) {\r\n            if (Array.isArray(array)) {\r\n                return new VectorType().fromArray(array);\r\n            }\r\n            return array;\r\n        }\r\n    }\r\n    return threegltviewer.vignettes = { createBackground };\r\n});\ndefine('skylark-threegltfviewer/Viewer',[\n    'skylark-threejs',\n    'skylark-threejs-ex/utils/stats',\n    'skylark-threejs-ex/loaders/GLTFLoader',\n    'skylark-threejs-ex/loaders/DRACOLoader',\n    'skylark-threejs-ex/controls/OrbitControls',\n    'skylark-threejs-ex/loaders/RGBELoader',\n    'skylark-datgui',\n    \"./threegltviewer\",\n    './environments',\n    './vignettes'\n], function (\n  THREE, \n  Stats, \n  GLTFLoader,\n  DRACOLoader, \n  OrbitControls, \n  RGBELoader, \n  datgui, \n  threegltviewer,\n  environments, \n  vignettes\n) {\n    'use strict';\n    const DEFAULT_CAMERA = '[default]';\n    const IS_IOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\n    const MAP_NAMES = [\n        'map',\n        'aoMap',\n        'emissiveMap',\n        'glossinessMap',\n        'metalnessMap',\n        'normalMap',\n        'roughnessMap',\n        'specularMap'\n    ];\n    const Preset = { ASSET_GENERATOR: 'assetgenerator' };\n    THREE.Cache.enabled = true;\n    class Viewer {\n        constructor(el, options) {\n            this.el = el;\n            this.options = options;\n            this.lights = [];\n            this.content = null;\n            this.mixer = null;\n            this.clips = [];\n            this.gui = null;\n            this.state = {\n                environment: options.preset === Preset.ASSET_GENERATOR ? environments.find(e => e.id === 'footprint-court').name : environments[1].name,\n                background: false,\n                playbackSpeed: 1,\n                actionStates: {},\n                camera: DEFAULT_CAMERA,\n                wireframe: false,\n                skeleton: false,\n                grid: false,\n                addLights: true,\n                exposure: 1,\n                textureEncoding: 'sRGB',\n                ambientIntensity: 0.3,\n                ambientColor: 16777215,\n                directIntensity: 0.8 * Math.PI,\n                directColor: 16777215,\n                bgColor1: '#ffffff',\n                bgColor2: '#353535'\n            };\n            this.prevTime = 0;\n            this.stats = new Stats();\n            this.stats.dom.height = '48px';\n            [].forEach.call(this.stats.dom.children, child => child.style.display = '');\n            this.scene = new THREE.Scene();\n            const fov = options.preset === Preset.ASSET_GENERATOR ? 0.8 * 180 / Math.PI : 60;\n            this.defaultCamera = new THREE.PerspectiveCamera(fov, el.clientWidth / el.clientHeight, 0.01, 1000);\n            this.activeCamera = this.defaultCamera;\n            this.scene.add(this.defaultCamera);\n            this.renderer = window.renderer = new THREE.WebGLRenderer({ antialias: true });\n            this.renderer.physicallyCorrectLights = true;\n            this.renderer.outputEncoding = THREE.sRGBEncoding;\n            this.renderer.setClearColor(13421772);\n            this.renderer.setPixelRatio(window.devicePixelRatio);\n            this.renderer.setSize(el.clientWidth, el.clientHeight);\n            this.pmremGenerator = new THREE.PMREMGenerator(this.renderer);\n            this.pmremGenerator.compileEquirectangularShader();\n            this.controls = new OrbitControls(this.defaultCamera, this.renderer.domElement);\n            this.controls.autoRotate = false;\n            this.controls.autoRotateSpeed = -10;\n            this.controls.screenSpacePanning = true;\n            this.vignette = vignettes.createBackground({\n                aspect: this.defaultCamera.aspect,\n                grainScale: IS_IOS ? 0 : 0.001,\n                colors: [\n                    this.state.bgColor1,\n                    this.state.bgColor2\n                ]\n            });\n            this.vignette.name = 'Vignette';\n            this.vignette.renderOrder = -1;\n            this.el.appendChild(this.renderer.domElement);\n            this.cameraCtrl = null;\n            this.cameraFolder = null;\n            this.animFolder = null;\n            this.animCtrls = [];\n            this.morphFolder = null;\n            this.morphCtrls = [];\n            this.skeletonHelpers = [];\n            this.gridHelper = null;\n            this.axesHelper = null;\n            this.addAxesHelper();\n            this.addGUI();\n            if (options.kiosk)\n                this.gui.close();\n            this.animate = this.animate.bind(this);\n            requestAnimationFrame(this.animate);\n            window.addEventListener('resize', this.resize.bind(this), false);\n        }\n\n        animate(time) {\n            requestAnimationFrame(this.animate);\n            const dt = (time - this.prevTime) / 1000;\n            this.controls.update();\n            this.stats.update();\n            this.mixer && this.mixer.update(dt);\n            this.render();\n            this.prevTime = time;\n        }\n\n        render() {\n            this.renderer.render(this.scene, this.activeCamera);\n            if (this.state.grid) {\n                this.axesCamera.position.copy(this.defaultCamera.position);\n                this.axesCamera.lookAt(this.axesScene.position);\n                this.axesRenderer.render(this.axesScene, this.axesCamera);\n            }\n        }\n\n        resize() {\n            const {clientHeight, clientWidth} = this.el.parentElement;\n            this.defaultCamera.aspect = clientWidth / clientHeight;\n            this.defaultCamera.updateProjectionMatrix();\n            this.vignette.style({ aspect: this.defaultCamera.aspect });\n            this.renderer.setSize(clientWidth, clientHeight);\n            this.axesCamera.aspect = this.axesDiv.clientWidth / this.axesDiv.clientHeight;\n            this.axesCamera.updateProjectionMatrix();\n            this.axesRenderer.setSize(this.axesDiv.clientWidth, this.axesDiv.clientHeight);\n        }\n\n        load(url, rootPath, assetMap) {\n            const baseURL = THREE.LoaderUtils.extractUrlBase(url);\n            return new Promise((resolve, reject) => {\n                const manager = new THREE.LoadingManager();\n                manager.setURLModifier((url, path) => {\n                    const normalizedURL = rootPath + decodeURI(url).replace(baseURL, '').replace(/^(\\.?\\/)/, '');\n                    if (assetMap.has(normalizedURL)) {\n                        const blob = assetMap.get(normalizedURL);\n                        const blobURL = URL.createObjectURL(blob);\n                        blobURLs.push(blobURL);\n                        return blobURL;\n                    }\n                    return (path || '') + url;\n                });\n                const loader = new b.GLTFLoader(manager);\n                loader.setCrossOrigin('anonymous');\n                const dracoLoader = new c.DRACOLoader();\n                dracoLoader.setDecoderPath('assets/draco/');\n                loader.setDRACOLoader(dracoLoader);\n                const blobURLs = [];\n                loader.load(url, gltf => {\n                    const scene = gltf.scene || gltf.scenes[0];\n                    const clips = gltf.animations || [];\n                    if (!scene) {\n                        throw new Error('This model contains no scene, and cannot be viewed here. However,' + ' it may contain individual 3D resources.');\n                    }\n                    this.setContent(scene, clips);\n                    blobURLs.forEach(URL.revokeObjectURL);\n                    resolve(gltf);\n                }, undefined, reject);\n            });\n        }\n\n        setContent(object, clips) {\n            this.clear();\n            const box = new THREE.Box3().setFromObject(object);\n            const size = box.getSize(new THREE.Vector3()).length();\n            const center = box.getCenter(new THREE.Vector3());\n            this.controls.reset();\n            object.position.x += object.position.x - center.x;\n            object.position.y += object.position.y - center.y;\n            object.position.z += object.position.z - center.z;\n            this.controls.maxDistance = size * 10;\n            this.defaultCamera.near = size / 100;\n            this.defaultCamera.far = size * 100;\n            this.defaultCamera.updateProjectionMatrix();\n            if (this.options.cameraPosition) {\n                this.defaultCamera.position.fromArray(this.options.cameraPosition);\n                this.defaultCamera.lookAt(new THREE.Vector3());\n            } else {\n                this.defaultCamera.position.copy(center);\n                this.defaultCamera.position.x += size / 2;\n                this.defaultCamera.position.y += size / 5;\n                this.defaultCamera.position.z += size / 2;\n                this.defaultCamera.lookAt(center);\n            }\n            this.setCamera(DEFAULT_CAMERA);\n            this.axesCamera.position.copy(this.defaultCamera.position);\n            this.axesCamera.lookAt(this.axesScene.position);\n            this.axesCamera.near = size / 100;\n            this.axesCamera.far = size * 100;\n            this.axesCamera.updateProjectionMatrix();\n            this.axesCorner.scale.set(size, size, size);\n            this.controls.saveState();\n            this.scene.add(object);\n            this.content = object;\n            this.state.addLights = true;\n            this.content.traverse(node => {\n                if (node.isLight) {\n                    this.state.addLights = false;\n                } else if (node.isMesh) {\n                    node.material.depthWrite = !node.material.transparent;\n                }\n            });\n            this.setClips(clips);\n            this.updateLights();\n            this.updateGUI();\n            this.updateEnvironment();\n            this.updateTextureEncoding();\n            this.updateDisplay();\n            window.content = this.content;\n            console.info('[glTF Viewer] THREE.Scene exported as `window.content`.');\n            this.printGraph(this.content);\n        }\n\n        printGraph(node) {\n            console.group(' <' + node.type + '> ' + node.name);\n            node.children.forEach(child => this.printGraph(child));\n            console.groupEnd();\n        }\n\n        setClips(clips) {\n            if (this.mixer) {\n                this.mixer.stopAllAction();\n                this.mixer.uncacheRoot(this.mixer.getRoot());\n                this.mixer = null;\n            }\n            this.clips = clips;\n            if (!clips.length)\n                return;\n            this.mixer = new THREE.AnimationMixer(this.content);\n        }\n\n        playAllClips() {\n            this.clips.forEach(clip => {\n                this.mixer.clipAction(clip).reset().play();\n                this.state.actionStates[clip.name] = true;\n            });\n        }\n\n        setCamera(name) {\n            if (name === DEFAULT_CAMERA) {\n                this.controls.enabled = true;\n                this.activeCamera = this.defaultCamera;\n            } else {\n                this.controls.enabled = false;\n                this.content.traverse(node => {\n                    if (node.isCamera && node.name === name) {\n                        this.activeCamera = node;\n                    }\n                });\n            }\n        }\n\n        updateTextureEncoding() {\n            const encoding = this.state.textureEncoding === 'sRGB' ? THREE.sRGBEncoding : THREE.LinearEncoding;\n            traverseMaterials(this.content, material => {\n                if (material.map)\n                    material.map.encoding = encoding;\n                if (material.emissiveMap)\n                    material.emissiveMap.encoding = encoding;\n                if (material.map || material.emissiveMap)\n                    material.needsUpdate = true;\n            });\n        }\n\n        updateLights() {\n            const state = this.state;\n            const lights = this.lights;\n            if (state.addLights && !lights.length) {\n                this.addLights();\n            } else if (!state.addLights && lights.length) {\n                this.removeLights();\n            }\n            this.renderer.toneMappingExposure = state.exposure;\n            if (lights.length === 2) {\n                lights[0].intensity = state.ambientIntensity;\n                lights[0].color.setHex(state.ambientColor);\n                lights[1].intensity = state.directIntensity;\n                lights[1].color.setHex(state.directColor);\n            }\n        }\n\n        addLights() {\n            const state = this.state;\n            if (this.options.preset === Preset.ASSET_GENERATOR) {\n                const hemiLight = new THREE.HemisphereLight();\n                hemiLight.name = 'hemi_light';\n                this.scene.add(hemiLight);\n                this.lights.push(hemiLight);\n                return;\n            }\n            const light1 = new THREE.AmbientLight(state.ambientColor, state.ambientIntensity);\n            light1.name = 'ambient_light';\n            this.defaultCamera.add(light1);\n            const light2 = new THREE.DirectionalLight(state.directColor, state.directIntensity);\n            light2.position.set(0.5, 0, 0.866);\n            light2.name = 'main_light';\n            this.defaultCamera.add(light2);\n            this.lights.push(light1, light2);\n        }\n\n        removeLights() {\n            this.lights.forEach(light => light.parent.remove(light));\n            this.lights.length = 0;\n        }\n\n        updateEnvironment() {\n            const environment = g.environments.filter(entry => entry.name === this.state.environment)[0];\n            this.getCubeMapTexture(environment).then(({envMap}) => {\n                if ((!envMap || !this.state.background) && this.activeCamera === this.defaultCamera) {\n                    this.scene.add(this.vignette);\n                } else {\n                    this.scene.remove(this.vignette);\n                }\n                this.scene.environment = envMap;\n                this.scene.background = this.state.background ? envMap : null;\n            });\n        }\n\n        getCubeMapTexture(environment) {\n            const {path} = environment;\n            if (!path)\n                return Promise.resolve({ envMap: null });\n            return new Promise((resolve, reject) => {\n                new e.RGBELoader().setDataType(THREE.UnsignedByteType).load(path, texture => {\n                    const envMap = this.pmremGenerator.fromEquirectangular(texture).texture;\n                    this.pmremGenerator.dispose();\n                    resolve({ envMap });\n                }, undefined, reject);\n            });\n        }\n\n        updateDisplay() {\n            if (this.skeletonHelpers.length) {\n                this.skeletonHelpers.forEach(helper => this.scene.remove(helper));\n            }\n            traverseMaterials(this.content, material => {\n                material.wireframe = this.state.wireframe;\n            });\n            this.content.traverse(node => {\n                if (node.isMesh && node.skeleton && this.state.skeleton) {\n                    const helper = new THREE.SkeletonHelper(node.skeleton.bones[0].parent);\n                    helper.material.linewidth = 3;\n                    this.scene.add(helper);\n                    this.skeletonHelpers.push(helper);\n                }\n            });\n            if (this.state.grid !== Boolean(this.gridHelper)) {\n                if (this.state.grid) {\n                    this.gridHelper = new THREE.GridHelper();\n                    this.axesHelper = new THREE.AxesHelper();\n                    this.axesHelper.renderOrder = 999;\n                    this.axesHelper.onBeforeRender = renderer => renderer.clearDepth();\n                    this.scene.add(this.gridHelper);\n                    this.scene.add(this.axesHelper);\n                } else {\n                    this.scene.remove(this.gridHelper);\n                    this.scene.remove(this.axesHelper);\n                    this.gridHelper = null;\n                    this.axesHelper = null;\n                    this.axesRenderer.clear();\n                }\n            }\n        }\n\n        updateBackground() {\n            this.vignette.style({\n                colors: [\n                    this.state.bgColor1,\n                    this.state.bgColor2\n                ]\n            });\n        }\n\n        addAxesHelper() {\n            this.axesDiv = document.createElement('div');\n            this.el.appendChild(this.axesDiv);\n            this.axesDiv.classList.add('axes');\n            const {clientWidth, clientHeight} = this.axesDiv;\n            this.axesScene = new THREE.Scene();\n            this.axesCamera = new THREE.PerspectiveCamera(50, clientWidth / clientHeight, 0.1, 10);\n            this.axesScene.add(this.axesCamera);\n            this.axesRenderer = new THREE.WebGLRenderer({ alpha: true });\n            this.axesRenderer.setPixelRatio(window.devicePixelRatio);\n            this.axesRenderer.setSize(this.axesDiv.clientWidth, this.axesDiv.clientHeight);\n            this.axesCamera.up = this.defaultCamera.up;\n            this.axesCorner = new THREE.AxesHelper(5);\n            this.axesScene.add(this.axesCorner);\n            this.axesDiv.appendChild(this.axesRenderer.domElement);\n        }\n\n        addGUI() {\n            const gui = this.gui = new datgui({\n                autoPlace: false,\n                width: 260,\n                hideable: true\n            });\n            const dispFolder = gui.addFolder('Display');\n            const envBackgroundCtrl = dispFolder.add(this.state, 'background');\n            envBackgroundCtrl.onChange(() => this.updateEnvironment());\n            const wireframeCtrl = dispFolder.add(this.state, 'wireframe');\n            wireframeCtrl.onChange(() => this.updateDisplay());\n            const skeletonCtrl = dispFolder.add(this.state, 'skeleton');\n            skeletonCtrl.onChange(() => this.updateDisplay());\n            const gridCtrl = dispFolder.add(this.state, 'grid');\n            gridCtrl.onChange(() => this.updateDisplay());\n            dispFolder.add(this.controls, 'autoRotate');\n            dispFolder.add(this.controls, 'screenSpacePanning');\n            const bgColor1Ctrl = dispFolder.addColor(this.state, 'bgColor1');\n            const bgColor2Ctrl = dispFolder.addColor(this.state, 'bgColor2');\n            bgColor1Ctrl.onChange(() => this.updateBackground());\n            bgColor2Ctrl.onChange(() => this.updateBackground());\n            const lightFolder = gui.addFolder('Lighting');\n            const encodingCtrl = lightFolder.add(this.state, 'textureEncoding', [\n                'sRGB',\n                'Linear'\n            ]);\n            encodingCtrl.onChange(() => this.updateTextureEncoding());\n            lightFolder.add(this.renderer, 'outputEncoding', {\n                sRGB: THREE.sRGBEncoding,\n                Linear: THREE.LinearEncoding\n            }).onChange(() => {\n                this.renderer.outputEncoding = Number(this.renderer.outputEncoding);\n                traverseMaterials(this.content, material => {\n                    material.needsUpdate = true;\n                });\n            });\n            const envMapCtrl = lightFolder.add(this.state, 'environment', g.environments.map(env => env.name));\n            envMapCtrl.onChange(() => this.updateEnvironment());\n            [\n                lightFolder.add(this.state, 'exposure', 0, 2),\n                lightFolder.add(this.state, 'addLights').listen(),\n                lightFolder.add(this.state, 'ambientIntensity', 0, 2),\n                lightFolder.addColor(this.state, 'ambientColor'),\n                lightFolder.add(this.state, 'directIntensity', 0, 4),\n                lightFolder.addColor(this.state, 'directColor')\n            ].forEach(ctrl => ctrl.onChange(() => this.updateLights()));\n            this.animFolder = gui.addFolder('Animation');\n            this.animFolder.domElement.style.display = 'none';\n            const playbackSpeedCtrl = this.animFolder.add(this.state, 'playbackSpeed', 0, 1);\n            playbackSpeedCtrl.onChange(speed => {\n                if (this.mixer)\n                    this.mixer.timeScale = speed;\n            });\n            this.animFolder.add({ playAll: () => this.playAllClips() }, 'playAll');\n            this.morphFolder = gui.addFolder('Morph Targets');\n            this.morphFolder.domElement.style.display = 'none';\n            this.cameraFolder = gui.addFolder('Cameras');\n            this.cameraFolder.domElement.style.display = 'none';\n            const perfFolder = gui.addFolder('Performance');\n            const perfLi = document.createElement('li');\n            this.stats.dom.style.position = 'static';\n            perfLi.appendChild(this.stats.dom);\n            perfLi.classList.add('gui-stats');\n            perfFolder.__ul.appendChild(perfLi);\n            const guiWrap = document.createElement('div');\n            this.el.appendChild(guiWrap);\n            guiWrap.classList.add('gui-wrap');\n            guiWrap.appendChild(gui.domElement);\n            gui.open();\n        }\n\n        updateGUI() {\n            this.cameraFolder.domElement.style.display = 'none';\n            this.morphCtrls.forEach(ctrl => ctrl.remove());\n            this.morphCtrls.length = 0;\n            this.morphFolder.domElement.style.display = 'none';\n            this.animCtrls.forEach(ctrl => ctrl.remove());\n            this.animCtrls.length = 0;\n            this.animFolder.domElement.style.display = 'none';\n            const cameraNames = [];\n            const morphMeshes = [];\n            this.content.traverse(node => {\n                if (node.isMesh && node.morphTargetInfluences) {\n                    morphMeshes.push(node);\n                }\n                if (node.isCamera) {\n                    node.name = node.name || `VIEWER__camera_${ cameraNames.length + 1 }`;\n                    cameraNames.push(node.name);\n                }\n            });\n            if (cameraNames.length) {\n                this.cameraFolder.domElement.style.display = '';\n                if (this.cameraCtrl)\n                    this.cameraCtrl.remove();\n                const cameraOptions = [DEFAULT_CAMERA].concat(cameraNames);\n                this.cameraCtrl = this.cameraFolder.add(this.state, 'camera', cameraOptions);\n                this.cameraCtrl.onChange(name => this.setCamera(name));\n            }\n            if (morphMeshes.length) {\n                this.morphFolder.domElement.style.display = '';\n                morphMeshes.forEach(mesh => {\n                    if (mesh.morphTargetInfluences.length) {\n                        const nameCtrl = this.morphFolder.add({ name: mesh.name || 'Untitled' }, 'name');\n                        this.morphCtrls.push(nameCtrl);\n                    }\n                    for (let i = 0; i < mesh.morphTargetInfluences.length; i++) {\n                        const ctrl = this.morphFolder.add(mesh.morphTargetInfluences, i, 0, 1, 0.01).listen();\n                        Object.keys(mesh.morphTargetDictionary).forEach(key => {\n                            if (key && mesh.morphTargetDictionary[key] === i)\n                                ctrl.name(key);\n                        });\n                        this.morphCtrls.push(ctrl);\n                    }\n                });\n            }\n            if (this.clips.length) {\n                this.animFolder.domElement.style.display = '';\n                const actionStates = this.state.actionStates = {};\n                this.clips.forEach((clip, clipIndex) => {\n                    let action;\n                    if (clipIndex === 0) {\n                        actionStates[clip.name] = true;\n                        action = this.mixer.clipAction(clip);\n                        action.play();\n                    } else {\n                        actionStates[clip.name] = false;\n                    }\n                    const ctrl = this.animFolder.add(actionStates, clip.name).listen();\n                    ctrl.onChange(playAnimation => {\n                        action = action || this.mixer.clipAction(clip);\n                        action.setEffectiveTimeScale(1);\n                        playAnimation ? action.play() : action.stop();\n                    });\n                    this.animCtrls.push(ctrl);\n                });\n            }\n        }\n        clear() {\n            if (!this.content)\n                return;\n            this.scene.remove(this.content);\n            this.content.traverse(node => {\n                if (!node.isMesh)\n                    return;\n                node.geometry.dispose();\n            });\n            traverseMaterials(this.content, material => {\n                MAP_NAMES.forEach(map => {\n                    if (material[map])\n                        material[map].dispose();\n                });\n            });\n        }\n    } ;\n\n    function traverseMaterials(object, callback) {\n        object.traverse(node => {\n            if (!node.isMesh)\n                return;\n            const materials = Array.isArray(node.material) ? node.material : [node.material];\n            materials.forEach(callback);\n        });\n    }\n\n    return Viewer;\n});\ndefine('skylark-threegltfviewer/SimpleDropzone',[\r\n\t\"skylark-langx-emitter\",\r\n\t\"skylark-jszip\",\r\n\t\"./threegltviewer\"\r\n],function(Emitter,jszip,threegltviewer) {\r\n\t//import ZipLoader from 'zip-loader';\r\n\r\n\t/**\r\n\t * Watches an element for file drops, parses to create a filemap hierarchy,\r\n\t * and emits the result.\r\n\t */\r\n\tclass SimpleDropzone {\r\n\r\n\t  /**\r\n\t   * @param  {Element} el\r\n\t   * @param  {Element} inputEl\r\n\t   */\r\n\t  constructor (el, inputEl) {\r\n\t    this.el = el;\r\n\t    this.inputEl = inputEl;\r\n\r\n\t    this.listeners = {\r\n\t      drop: [],\r\n\t      dropstart: [],\r\n\t      droperror: []\r\n\t    };\r\n\r\n\t    this._onDragover = this._onDragover.bind(this);\r\n\t    this._onDrop = this._onDrop.bind(this);\r\n\t    this._onSelect = this._onSelect.bind(this);\r\n\r\n\t    el.addEventListener('dragover', this._onDragover, false);\r\n\t    el.addEventListener('drop', this._onDrop, false);\r\n\t    inputEl.addEventListener('change', this._onSelect);\r\n\t  }\r\n\r\n\t  /**\r\n\t   * @param  {string}   type\r\n\t   * @param  {Function} callback\r\n\t   * @return {SimpleDropzone}\r\n\t   */\r\n\t  on (type, callback) {\r\n\t    this.listeners[type].push(callback);\r\n\t    return this;\r\n\t  }\r\n\r\n\t  /**\r\n\t   * @param  {string} type\r\n\t   * @param  {Object} data\r\n\t   * @return {SimpleDropzone}\r\n\t   */\r\n\t  _emit (type, data) {\r\n\t    this.listeners[type]\r\n\t      .forEach((callback) => callback(data));\r\n\t    return this;\r\n\t  }\r\n\r\n\t  /**\r\n\t   * Destroys the instance.\r\n\t   */\r\n\t  destroy () {\r\n\t    const el = this.el;\r\n\t    const inputEl = this.inputEl;\r\n\r\n\t    el.removeEventListener(this._onDragover);\r\n\t    el.removeEventListener(this._onDrop);\r\n\t    inputEl.removeEventListener(this._onSelect);\r\n\r\n\t    delete this.el;\r\n\t    delete this.inputEl;\r\n\t    delete this.listeners;\r\n\t  }\r\n\r\n\t  /**\r\n\t   * @param  {Event} e\r\n\t   */\r\n\t  _onDrop (e) {\r\n\t    e.stopPropagation();\r\n\t    e.preventDefault();\r\n\r\n\t    this._emit('dropstart');\r\n\r\n\t    let entries;\r\n\t    if (e.dataTransfer.items) {\r\n\t      entries = [].slice.call(e.dataTransfer.items)\r\n\t        .map((item) => item.webkitGetAsEntry());\r\n\t    } else if ((e.dataTransfer.files||[]).length === 1) {\r\n\t      const file = e.dataTransfer.files[0];\r\n\t      if (this._isZip(file)) {\r\n\t        this._loadZip(file);\r\n\t        return;\r\n\t      } else {\r\n\t        this._emit('drop', {files: new Map([[file.name, file]])});\r\n\t        return;\r\n\t      }\r\n\t    }\r\n\r\n\t    if (!entries) {\r\n\t      this._fail('Required drag-and-drop APIs are not supported in this browser.');\r\n\t    }\r\n\r\n\t    if (entries.length === 1 && entries[0].name.match(/\\.zip$/)) {\r\n\t      entries[0].file((file) => this._loadZip(file));\r\n\t    } else {\r\n\t      this._loadNextEntry(new Map(), entries);\r\n\t    }\r\n\t  }\r\n\r\n\t  /**\r\n\t   * @param  {Event} e\r\n\t   */\r\n\t  _onDragover (e) {\r\n\t    e.stopPropagation();\r\n\t    e.preventDefault();\r\n\t    e.dataTransfer.dropEffect = 'copy'; // Explicitly show this is a copy.\r\n\t  }\r\n\r\n\t  /**\r\n\t   * @param  {Event} e\r\n\t   */\r\n\t  _onSelect (e) {\r\n\t    this._emit('dropstart');\r\n\r\n\t    // HTML file inputs do not seem to support folders, so assume this is a flat file list.\r\n\t    const files = [].slice.call(this.inputEl.files);\r\n\r\n\t    // Automatically decompress a zip archive if it is the only file given.\r\n\t    if (files.length === 1 && this._isZip(files[0])) {\r\n\t      this._loadZip(files[0]);\r\n\t      return;\r\n\t    }\r\n\r\n\t    const fileMap = new Map();\r\n\t    files.forEach((file) => fileMap.set(file.name, file));\r\n\t    this._emit('drop', {files: fileMap});\r\n\t  }\r\n\r\n\t  /**\r\n\t   * Iterates through a list of FileSystemEntry objects, creates the fileMap\r\n\t   * tree, and emits the result.\r\n\t   * @param  {Map<string, File>} fileMap\r\n\t   * @param  {Array<FileSystemEntry>} entries\r\n\t   */\r\n\t  _loadNextEntry (fileMap, entries) {\r\n\t    const entry = entries.pop();\r\n\r\n\t    if (!entry) {\r\n\t      this._emit('drop', {files: fileMap});\r\n\t      return;\r\n\t    }\r\n\r\n\t    if (entry.isFile) {\r\n\t      entry.file((file) => {\r\n\t        fileMap.set(entry.fullPath, file);\r\n\t        this._loadNextEntry(fileMap, entries);\r\n\t      }, () => console.error('Could not load file: %s', entry.fullPath));\r\n\t    } else if (entry.isDirectory) {\r\n\t      // readEntries() must be called repeatedly until it stops returning results.\r\n\t      // https://www.w3.org/TR/2012/WD-file-system-api-20120417/#the-directoryreader-interface\r\n\t      // https://bugs.chromium.org/p/chromium/issues/detail?id=378883\r\n\t      const reader = entry.createReader();\r\n\t      const readerCallback = (newEntries) => {\r\n\t        if (newEntries.length) {\r\n\t          entries = entries.concat(newEntries);\r\n\t          reader.readEntries(readerCallback);\r\n\t        } else {\r\n\t          this._loadNextEntry(fileMap, entries);\r\n\t        }\r\n\t      };\r\n\t      reader.readEntries(readerCallback);\r\n\t    } else {\r\n\t      console.warn('Unknown asset type: ' + entry.fullPath);\r\n\t      this._loadNextEntry(fileMap, entries);\r\n\t    }\r\n\t  }\r\n\r\n\t  /**\r\n\t   * Inflates a File in .ZIP format, creates the fileMap tree, and emits the\r\n\t   * result.\r\n\t   * @param  {File} file\r\n\t   */\r\n\t  _loadZip (file) {\r\n\t    const pending = [];\r\n\t    const fileMap = new Map();\r\n\r\n\t    const traverse = (node) => {\r\n\t      if (node.directory) {\r\n\t        node.children.forEach(traverse);\r\n\t      } else if (node.name[0] !== '.') {\r\n\t        pending.push(new Promise((resolve) => {\r\n\t          node.getData(new zip.BlobWriter(), (blob) => {\r\n\t            blob.name = node.name;\r\n\t            fileMap.set(node.getFullname(), blob);\r\n\t            resolve();\r\n\t          });\r\n\t        }));\r\n\t      }\r\n\t    };\r\n\r\n\t    ZipLoader.unzip(file).then((archive) => {\r\n\t      Object.keys(archive.files).forEach((path) => {\r\n\t        if (path.match(/\\/$/)) return;\r\n\t        const fileName = path.replace(/^.*[\\\\\\/]/, '');\r\n\t        fileMap.set(path, new File([archive.files[path].buffer], fileName));\r\n\t      });\r\n\t      this._emit('drop', {files: fileMap, archive: file});\r\n\t    });\r\n\t  }\r\n\r\n\t  /**\r\n\t   * @param  {File} file\r\n\t   * @return {Boolean}\r\n\t   */\r\n\t  _isZip (file) {\r\n\t    return file.type === 'application/zip' || file.name.match(/\\.zip$/);\r\n\t  }\r\n\r\n\t  /**\r\n\t   * @param {string} message\r\n\t   * @throws\r\n\t   */\r\n\t  _fail (message) {\r\n\t    this._emit('droperror', {message: message});\r\n\t  }\r\n\t}\r\n\r\n\treturn threegltviewer.SimpleDropzone = SimpleDropzone;\r\n\r\n});\r\n\r\n \ndefine('skylark-threegltfviewer/App',[\n    'skylark-threejs-ex/WebGL',\n    \"./threegltviewer\",\n    './Viewer',\n    './SimpleDropzone'\n], function (WebGL, threegltviewer,Viewer, SimpleDropzone) {\n    'use strict';\n    \n    class App {\n        constructor(el, location) {\n            //const hash = location.hash ? queryString.parse(location.hash) : {};\n            const hash = {};\n            this.options = {\n                kiosk: Boolean(hash.kiosk),\n                model: hash.model || '',\n                preset: hash.preset || '',\n                cameraPosition: hash.cameraPosition ? hash.cameraPosition.split(',').map(Number) : null\n            };\n            this.el = el;\n            this.viewer = null;\n            this.viewerEl = null;\n            this.spinnerEl = el.querySelector('.spinner');\n            this.dropEl = el.querySelector('.dropzone');\n            this.inputEl = el.querySelector('#file-input');\n            //this.validationCtrl = new Validation(el);\n            this.createDropzone();\n            this.hideSpinner();\n            const options = this.options;\n            if (options.kiosk) {\n                const headerEl = document.querySelector('header');\n                headerEl.style.display = 'none';\n            }\n            if (options.model) {\n                this.view(options.model, '', new Map());\n            }\n        }\n\n        createDropzone() {\n            const dropCtrl = new SimpleDropzone(this.dropEl, this.inputEl);\n            dropCtrl.on('drop', ({files}) => this.load(files));\n            dropCtrl.on('dropstart', () => this.showSpinner());\n            dropCtrl.on('droperror', () => this.hideSpinner());\n        }\n\n        createViewer() {\n            this.viewerEl = document.createElement('div');\n            this.viewerEl.classList.add('viewer');\n            this.dropEl.innerHTML = '';\n            this.dropEl.appendChild(this.viewerEl);\n            this.viewer = new Viewer(this.viewerEl, this.options);\n            return this.viewer;\n        }\n\n        load(fileMap) {\n            let rootFile;\n            let rootPath;\n            Array.from(fileMap).forEach(([path, file]) => {\n                if (file.name.match(/\\.(gltf|glb)$/)) {\n                    rootFile = file;\n                    rootPath = path.replace(file.name, '');\n                }\n            });\n            if (!rootFile) {\n                this.onError('No .gltf or .glb asset found.');\n            }\n            this.view(rootFile, rootPath, fileMap);\n        }\n\n        view(rootFile, rootPath, fileMap) {\n            if (this.viewer)\n                this.viewer.clear();\n            const viewer = this.viewer || this.createViewer();\n            const fileURL = typeof rootFile === 'string' ? rootFile : URL.createObjectURL(rootFile);\n            const cleanup = () => {\n                this.hideSpinner();\n                if (typeof rootFile === 'object')\n                    URL.revokeObjectURL(fileURL);\n            };\n            viewer.load(fileURL, rootPath, fileMap).catch(e => this.onError(e)).then(gltf => {\n                //if (!this.options.kiosk) {\n                //    this.validationCtrl.validate(fileURL, rootPath, fileMap, gltf);\n                //}\n                cleanup();\n            });\n        }\n\n        onError(error) {\n            let message = (error || {}).message || error.toString();\n            if (message.match(/ProgressEvent/)) {\n                message = 'Unable to retrieve this file. Check JS console and browser network tab.';\n            } else if (message.match(/Unexpected token/)) {\n                message = `Unable to parse file content. Verify that this file is valid. Error: \"${ message }\"`;\n            } else if (error && error.target && error.target instanceof Image) {\n                message = 'Missing texture: ' + error.target.src.split('/').pop();\n            }\n            window.alert(message);\n            console.error(error);\n        }\n\n        showSpinner() {\n            this.spinnerEl.style.display = '';\n        }\n\n        hideSpinner() {\n            this.spinnerEl.style.display = 'none';\n        }\n    }\n\n    return threegltviewer.App = App;\n});\ndefine('skylark-threegltfviewer/main',[\r\n\t\"./threegltviewer\",\r\n\t\"./App\"\r\n],function(threegltviewer){\r\n\treturn threegltviewer;\r\n});\ndefine('skylark-threegltfviewer', ['skylark-threegltfviewer/main'], function (main) { return main; });\n\n"]}